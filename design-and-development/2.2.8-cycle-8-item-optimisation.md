# 2.2.8 Cycle 8: Item collection

## Design

### Objectives

In this cycle, I will aim to allow picking up and dropping items, and a simple interface for players to see and interact with their items. I will also need to optimise item rendering, as loading all items to the screen causes significant performance issues (see [cycle-1-4.md](cycle-1-4.md "mention")). I hope to have a button to use the item, and a button to drop it. Coming within range of an item will trigger a "Pick up" button at the bottom of the screen, which will give an error if the user's inventory is full

* [x] Item inventory interface, with a list of items, and a description on each items individual page.
  * [x] A drop button which removes the item from the players inventory and adds it to the map
  * [x] A use button which triggers an items power (non-functional)
* [x] A "Pick up" item button which appears when an item is within range, and adds the item to the inventory, while removing it from the map.
* [x] Optimise item loading - potentially so players can only see items within a certain radius

### Usability

* If the user's inventory is full, the "Pick Up" button will appear red, with an error notification appearing if its clicked.
* An item's "use" button should be customised depending on its function - i.e. a GPS Jammer item would have the use button say "JAM GPS"
* ~~Make a blurry or otherwise interesting border around the player's item visibility range, to indicate that their may be more items beyond said boundary~~

### Key Variables

| Variable name | Use                                                                     |
| ------------- | ----------------------------------------------------------------------- |
| player.items  | A list which stores all items a player currently has in their inventory |
| items         | A list which stores all items currently on the map                      |

### Pseudocode

```
subroutine pickup_item(item, player)
    remove item from items array
    add item to player.items array
    send updated items to all players of same player.type
    send item_pickup message to player
end subroutine

subroutine drop_item(item, player)
    remove item from player.items array
    add item to items array
    send updated items to all players of same player.type
    send item_dropped message to player    
end subroutine
```

### UI Mockup

<figure><img src="../.gitbook/assets/image (1) (3) (2).png" alt=""><figcaption><p>From Left to Right: A "Pick up" button (green when inventory space, red when full). A example inventory, with 2/6 empty slots. A GPS Jammer screen with a description, Jam and Drop button.</p></figcaption></figure>

## Development

### Item rendering performance

Initially, I had planned to solve the problem of item rendering simply by decreasing the number of nodes displayed to the client. This solution was not ideal, and whilst debugging the item rendering component, I discovered that it was re-rendering almost 10 times a second.

I discovered this issue by logging a `rendered` message to the console when the component renders. To work out the cause of these rerenders, I used the "Flamegraph" function within React Dev Tools - it turned out to be down to a parent component re-rendering, and causing all of the children to also re-render.&#x20;

<figure><img src="../.gitbook/assets/image (2).png" alt=""><figcaption><p>A screenshot demonstrating the React Dev Tools profiler</p></figcaption></figure>

These extra re-renders were a huge performance hit, causing massively unnecessary computation. This was rectified by using what's known as a React Higher Order Component (HOC), called `React.memo`.

> _If your component renders the same result given the same props, you can wrap it in a call to `React.memo` for a performance boost in some cases by memoizing the result. This means that React will skip rendering the component, and reuse the last rendered result_.
>
> \- React.JS Docs ([https://reactjs.org/docs/react-api.html#reactmemo](https://reactjs.org/docs/react-api.html#reactmemo))

{% code title="React.memo usage" %}
```tsx
export const ItemMarkers = React.memo(
  (props: {items: Item[]; location: GeolocationCoordinates}) => {
    // Instead of using hooks, we pass in the item and location data as props, from
    // the parent component
    const {items, location} = props;

    if (!items || !location) return null;

    return (
      <>
        {items.map(item => <ItemComponent item={item}/>}
      </>
    );
  },
  (prev, next) => {
    // If this statement returns true (the previous props = the new props), then
    // the component will not rerender. We can improve performance when comparing
    // prev.items and next.items, by simply comparing the lengths of the lists, as
    // the actual item objects will not be mutated.
    return (
      prev.items.length === next.items.length &&
      prev.location.latitude === next.location.latitude &&
      prev.location.longitude === next.location.longitude
    );
  }
);
```
{% endcode %}

### "Pick up" button

In order to compute when to display a "Pick up" button, I iterated over each item to find the first one within a given distance. I also made sure to block item pickup if the user's inventory was full, and render a red background.

<figure><img src="../.gitbook/assets/image (11).png" alt=""><figcaption><p>A screenshot of the "Pick up" button</p></figcaption></figure>

Otherwise, I would emit an `item-pickup` event to the server.

```tsx
export default () => {
    const [location, setLocation] = useLocation();
    const [items] = useItems();
    const me = useMe();
    ...
    const pickableItem = items?.find(i => distance(i.location, location) < 100);
    
    return (
        <MapContainer>
            ...
            {location && pickableItem && (
                <Button
                    onClick={() => {
                        if (me?.items?.length === 6) {
			    toast.error('Inventory full');
			} else {
			    socket?.emit('item-pickup', {id: pickableItem.id});
		        }
		    }}
		    colorScheme={me?.items?.length === 6 ? 'red' : 'green'}
		>Pick up</Button>
	    }
	    ...
	</MapContainer>
    )
}
```

On receipt of the `item-pickup` message by the server, several processes need to occur (see [#pseudocode](2.2.8-cycle-8-item-optimisation.md#pseudocode "mention")). We need to get the item by its id, append it to the player object, and remove it from the game object, before sending the updated data to the client.

<pre class="language-typescript"><code class="lang-typescript">class Player {
    ...
  pickupItem(itemId: string) {
    // Return the item from game.items, and remove it from the game.items list
    const item = this.game.pickupItem(itemId);
    if (!item) return;
    // Add item to the player
<strong>    this.items.push(item);
</strong><strong>    // Send an 'item-pickup' confirmation to the requesting player
</strong>    this.socket.emit('item-pickup', {
      id: item.id,
    });
    // Send an 'item-remove' message to all *other* players of the same type, so 
    // their map remains in sync.
    this.socket.to(this.id + item?.info.type).emit('item-remove', {
      id: item.id,
<strong>    });
</strong>  }
  ...
}</code></pre>

Once these messages are received by the client, it mutates its local state within `SocketHandler.tsx` ([cycle-1-3.md](cycle-1-3.md "mention")), ensuring all client data is up-to-date.

{% tabs %}
{% tab title="item-remove" %}
This removes the item from the game object, and hence, the map.

<pre class="language-typescript"><code class="lang-typescript"><strong>setGame(prev => ({
</strong>    ...prev!,
    items: prev!.items.filter(i => i.id !== data.id),
}));</code></pre>
{% endtab %}

{% tab title="item-pickup" %}
This message is received by the requesting player, confirming their request. The item is appended to their player, and removed from the map.

```typescript
const item = game?.items.find(i => i.id === data.id)!;
if (me) {
  setPlayers(prev => [
    ...prev.filter(p => p.id !== me.id),
    {...me, items: [...(me.items || []), item]},
  ]);
}
setGame(prev => ({
  ...prev!,
  items: prev!.items.filter(i => i.id !== data.id),
}));
```
{% endtab %}
{% endtabs %}

### Inventory UI

The inventory UI was relatively painless to implement, using the [#ui-mockup](2.2.8-cycle-8-item-optimisation.md#ui-mockup "mention") as a rough reference, and a CSS grid structure, to ensure sensible wrapping and dimensions on a range of screen sizes.

In order to trigger opening the inventory, I added a `page` state to `<GameContainer/>` which would store the currently opened page (`inventory`, `settings` or `false`).

```tsx
export const GameContainer = () => {
  const [game, setGame] = useGame();
  // Here we define the 'page' state, intially setting it to false (no pages open)
  const [page, setPage] = useState<false | 'inventory' | 'settings'>(false);
  const socket = useSocket();
  const me = useMe();

  ...

  return (
    <Flex h={'100vh'} w={'full'} flexDir={'column'}>
      <Flex h={'full'} position={'relative'}>
        {me?.catching && <CatchOverlay />}
        {game.hasEnded && <WinLose />}
        // Displays the inventory page if appropriate, and passes a function to it
        // to close the page.
        {page === 'inventory' && <Inventory closeFn={() => setPage(false)} />}
        <Map />
      </Flex>
      <GameFooter
        // Passes functions to GameFooter, which are passed on to the 🎒 & ⚙️ buttons,
        // toggling the opening of each page.
        inventoryOnClick={() => setPage(p => (p === 'inventory' ? false : 'inventory'))}
        settingsOnClick={() => setPage(p => (p === 'settings' ? false : 'settings'))}
      />
    </Flex>
  );
};
```

The inventory page renders a grid of items, with each item containing the logic to open and display its respective "action" page.

<pre class="language-tsx"><code class="lang-tsx">// An object which stores text relevant to each item. This is stored on client
// and not sent over websockets to reduce bandwidth.
export const itemDetails = {
  gpjs: {
    desc: 'A GPS Jammer that will disable GPS functionality for all other hunters. Lasts 5 minutes',
    action: 'JAM GPS',
  },
} as Record&#x3C;Item['info']['code'], {desc: string; action: string}>;

<strong>export const GridItem = (props: {item: Item | undefined}) => {
</strong><strong>  // Internal state which stores whether or not to display an items 'action' page
</strong>  const [open, setOpen] = useState(false);
  const socket = useSocket();
  const [playerLocation] = useLocation();

  const item = props.item;

  if (!socket || !playerLocation) return null;
  
  if (open &#x26;&#x26; item) {
    return (
      &#x3C;VStack
        position={'absolute'}
        w={'100%'}
        height={'100%'}
        overflowY={'scroll'}
        bg={'white'}
        // Ensures the item page is displayed *above* the inventory page
        zIndex={10000}
        spacing={0}
        top={0}
        left={0}
      >
        &#x3C;VStack spacing={0} p={4} w="full" pb={2}>
          &#x3C;HStack w="full" justifyContent={'space-between'}>
            &#x3C;Icon as={RiArrowLeftSLine} w={8} h={8} onClick={() => setOpen(false)} />
            &#x3C;Heading size={'xl'}>{item.info.name}&#x3C;/Heading>
            &#x3C;Box w={8} />
          &#x3C;/HStack>
          // Displays the friendly rarity name (e.g. Rare), and the corresponding
          // color. See Cycle 6 for more details
          &#x3C;Text color={rarityArray[item.info.rarity].color} fontSize={'lg'}>
            {title(rarityArray[item.info.rarity].text)}
          &#x3C;/Text>
        &#x3C;/VStack>
        // For now, items just use a kitten placeholder image :)
        &#x3C;Image src={'https://placekitten.com/200/200'} w={'full'} />
        &#x3C;VStack p={4}>
          // Displays item description
          &#x3C;Text fontSize={'lg'} color="gray">
            {itemDetails[item.info.code].desc}
          &#x3C;/Text>
          // Displays action button (non-functional)
          &#x3C;Button bg="red.500" w="full" color="white" fontSize={'32'}>
            {itemDetails[item.info.code].action}
          &#x3C;/Button>
          // Displays drop button
          &#x3C;Button
            bg="blue.500"
            w="full"
            color="white"
            fontSize={'32'}
            onClick={() =>
              // Sends an item-drop event, with the item id, AND the
              // current location of the player.
              socket.emit('item-drop', {
                id: item.id,
                location: {
                  lat: playerLocation.latitude,
                  lng: playerLocation.longitude,
                },
              })
            }
          >
            DROP
          &#x3C;/Button>
        &#x3C;/VStack>
      &#x3C;/VStack>
    );
  }

  return (
    &#x3C;VStack
      spacing={0}
      onClick={() => item &#x26;&#x26; setOpen(true)}
      justifyContent={'center'}
      boxShadow={'0px 0px 0px 2px var(--chakra-colors-gray-200) inset'}
    >
      // Displays a thumbnail, item name and level if there is an item in said
      // inventory slot, otherwise, displays 'Empty' message.
      {item ? (
        &#x3C;>
          &#x3C;Image src={'https://placekitten.com/200/200'} />
          &#x3C;VStack
            justifyContent={'center'}
            w={'full'}
            h="full"
            borderTop={'none'}
            spacing={0}
            p={1}
          >
            &#x3C;Heading size={'md'}>{item.info.name}&#x3C;/Heading>
            &#x3C;Text color={rarityArray[item.info.rarity].color}>
              {title(rarityArray[item.info.rarity].text)}
            &#x3C;/Text>
          &#x3C;/VStack>
        &#x3C;/>
      ) : (
        &#x3C;Text>Empty&#x3C;/Text>
      )}
    &#x3C;/VStack>
  );
};</code></pre>

#### Dropping Items

<figure><img src="../.gitbook/assets/image (5).png" alt=""><figcaption><p>A flowchart to show the dropping item routine</p></figcaption></figure>

The above flowchart demonstrates the processes that occur when the user clicks the drop button.

{% tabs %}
{% tab title="Client ->" %}
A snippet of the `<GridItem/>` component, showing the socket message sent when the user clicks the item drop button.

```typescript
const item = props.item
const [playerLocation] = useLocation();

return (
  ...
  <Button onClick={
    socket.emit('item-drop', {
      id: item.id,
      location: {
        // The current players location is sent when the item is dropped
        // as the item will be added to the map in the same place.
        lat: playerLocation.latitude,
        lng: playerLocation.longitude,
      },
    })
  }>DROP</Button>
  ...
)
```
{% endtab %}

{% tab title="Server ->" %}
This is the subroutine called within the player object when a 'drop-item' message is received.

```typescript
export class Player {
  items: Item[]
  game: Game
  socket: Socket
  
  ...
  
  dropItem(itemToDrop: {id: string; location: Item['location']}) {
    // Item object is found using providied id
    const item = this.items.find(i => i.id === itemToDrop.id);
    if (!item) return;
    // Item object location is updated using provided location
    item.location = itemToDrop.location;
    // Removes item from player
    this.items = this.items.filter(i => i.id === itemToDrop.id);
    // Adds item to game
    this.game.dropItem(item);
    // Sends item-drop confirmation with Item object to requesting player
    this.socket.emit('item-drop', {
      id: item.id,
      location: item.location,
      info: item.info,
    });
    // Sends item-add message with Item object to all players of the same type
    this.socket.to(this.id + item?.info.type).emit('item-add', {
      id: item.id,
      location: item.location,
      info: item.info,
    });
  }
}
```

The `game.dropItem` subroutine is a very simple one-liner, adding the item to the game object Items array

```typescript
export class Game {
  items: Item[]
  
  ...
  
  dropItem(item: Item) {
    this.items.push(item);
  }
}
```
{% endtab %}

{% tab title="Client(s)" %}
These listeners are contained within `<SocketHandler/>` and are responsible for mutating the client items (and players), on receipt of `item-drop` and `item-add` messages

```typescript
const listeners = {
  ...
  'item-drop': data => {
    if (me?.items) {
      // Remove the dropped item from the player.item list.
      setPlayers(prev => [
        ...prev.filter(p => p.id !== me.id),
        {...me, items: me.items?.filter(i => i.id !== data.id)},
      ]);
      // Adds the dropped item to the game, and hence the map
      setGame(prev => ({
        ...prev!,
        items: [...prev!.items, data],
      }));
    }
  },
  'item-add': data => {
    // Adds the dropped item to the game, and hence the map
    setGame(prev => ({
      ...prev!,
      items: [...prev!.items, data],
    }));
  },
};
```
{% endtab %}
{% endtabs %}

### Challenges

It was challenging to implement `React.memo` as discussed in [#item-rendering-performance](2.2.8-cycle-8-item-optimisation.md#item-rendering-performance "mention"). It was a React feature which I was unfamiliar with, but I managed to work out the correct function composition by reading the documentation and looking at other people's examples.

## Testing

### Tests

| Test | Instructions                                                                                 | What I expect                                                                                                                         | What actually happens | Pass/Fail |
| ---- | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | --------- |
| 1    | Create a game, and move towards an item (within \~20m)                                       | A green "pick up" button should appear at the bottom of the user's screen                                                             | As expected           | Pass      |
| 1.1  | Click the pick-up button, and then click the 🎒                                              | The item disappears from the map, and is displayed in the inventory                                                                   | As expected           | Pass      |
| 1.2  | Continue until you've picked up 6 items, and move within range of another item               | A red "pick up" button should appear, which will display an "Inventory Full" message when clicked. No change to the item should occur | As expected           | Pass      |
| 2    | Pickup an item, click on 🎒 and then click on an item                                        | A page should appear with more details about the item, a drop button and an action button                                             | As expected           | Pass      |
| 2.1  | Move, and then click the drop button                                                         | The item should disappear from the inventory, and the user should see the item at their current location on the map.                  | As expected           | Pass      |
| 3    | Repeat tests 2 and 2.1 with a second player  of the same type connected and observe the map. | An item should disappear from the map, before reappearing again in a different location                                               | As expected           | Pass      |

{% hint style="info" %}
Although not explicitly a test, when adding a second player and clicking "Switch Role", the items would be incorrect for their role when the game started. To rectify this, I created a new socket message called `game-update`, allowing me to update the entire item array on the client, similarly to the `game-init` event.

I called this from within the `player.updatePref()` method, sending the items appropriate for the players new role to the client.
{% endhint %}

### Evidence

{% embed url="https://drive.google.com/file/d/1jPOHC3hXSvu8Z1Zmkveb-NkuyWEFFhwD/view?usp=sharing" %}
