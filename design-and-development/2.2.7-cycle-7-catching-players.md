# 2.2.7 Cycle 7: Catching players

## Design

### Objectives

I concede that it seems strange to pivot from adding more item mechanics, to follow on from [cycle-1-4.md](cycle-1-4.md "mention"), however, there is a reason for it. Throughout the development I have started to realise that the scope of my project may have been too large, and my features proposed in [1.4a-features-of-the-proposed-solution.md](../1-analysis/1.4a-features-of-the-proposed-solution.md "mention") are unlikely to be fully implemented. Therefore, I will implement the ability to catch players, and for a certain team to "win" the game. This will ensure that the game is playable, and could be presented as an MVP (minimum viable product). To achieve this, there are several things I intend to add:

* [x] A game time setting in the creation page, which, once reached, will cause the game to end and the "Hunted" team to be declared victorious.
* [x] A "Catch" screen should appear when a Hunter is within 5m of a player, which will cause the game to end for the Hunted player when clicked (spectator mode TBA in a later cycle)
* [x] The game should end and the Hunters declared victorious once all Hunted players are caught

### Usability Features

* The game duration should be visible. I will change the game time indicator to a countdown
* There should be 10 minute, 5 minute and 1 minute countdown messages sent towards the end of the game
* The Catch button should be large and appear on top of the map
* When a game ends and a team wins, there should be alternate "You Win/Lose" message broadcast to players screens

### Key Variables

| Variable name         | Use                                                                      |
| --------------------- | ------------------------------------------------------------------------ |
| game.options.duration | A game object attribute that will store the max game duration in seconds |
| player.status         | Stores whether a player is alive or a spectator                          |

### Pseudocode

```
subroutine player_location_update(player, location)
    if (player.type = "hunter")
        for huntedPlayer of huntedPlayers
            if (distance(huntedPlayer.location, location) < 6)
                send message catch-enabled with huntedPlayer details to player
            end if
        end for
    end if
    ...
end subroutine

subroutine on_catch_message(huntedPlayer
    if (distance(huntedPlayer.location, location) < 6)
        set huntedPlayer status to spectator
        send message game-over to huntedPlayer
        send spectator data to huntedPlayer
        send message catch-disabled to player
        if (no more hunted players)
            end_game()
        end if
    end if
end subroutine

subroutine game_start(game)
    ...
    set timeout (duration: game.duration) end_game()
end subroutine

subroutine end_game()
    if (huntedPlayers length > 0)
        broadcast hunted players won
    else
        broadcast hunters won
    remove game from games list
end subroutine
```

### UI Mockup

<figure><img src="../.gitbook/assets/image.png" alt=""><figcaption><p>From Left to Right: The catch screen, shown when a Hunter is near a Hunted Player; A win screen with a blue overlay, that exists the game with a countdown; A red lose screen</p></figcaption></figure>

## Development

This cycle was fairly simple to implement; refactoring done in [cycle-1-3.md](cycle-1-3.md "mention") made new socket events and game logic easy to implement. &#x20;

#### Catching Players

On each location update from every player I will calculate if catching is possible. For instance, if the player sending a location update is a _hunted_ player, then the game will check whether there are any hunters within a given range (and vice-versa for hunters).

```typescript
updateLocation(location: GeolocationCoordinates) {
  if (this.type === 'hunter') {
    this.socket.to(this.game.id + 'hunter').emit('player-location', {
      id: this.id,
      location: this.location,
    });
  } else {
    if (this.catchers.length) {
      this.catchers.forEach(c => {
        if (c.location && distance(c.location, this.location!) > 400) {
          c.unsetCatchable();
        }
      });
    }
  }

  const playerInRange = this.game[this.type === 'hunter' ? 'hunted' : 'hunter'].filter(p => {
    console.log(p.location, this.location);
    return p.location && distance(p.location, this.location!) <= 400;
  })[0];

  if (playerInRange) {
    console.log('setting catchable');
    if (this.type === 'hunted') {
      playerInRange.setCatchable(this);
    } else {
      this.setCatchable(playerInRange);
    }
  } else if (this.catching) {
    this.unsetCatchable();
  }
}
```

