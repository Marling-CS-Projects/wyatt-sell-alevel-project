# 1.4b Computational Methods

Computational Thinking is a collection of technique used to solve problems with a computer algorithm. It involves analysing a problem, and working out the optimal and most future-proof way it can be represented in computer code. This is incredibly important for large programming projects such as my game, and the reasons are outlined below:

* Data needs to be shared and communicated across multiple devices in realtime. This will rely on a computers ability to handle multiple concurrent streams of data, and interact between them.
* A user needs to have a clear UI with "items" overlayed onto the real world. A computer program is needed here as it is not possible or feasible to have physical, working items in specific locations.
* Various in-game items and actions will need to be simulated as they are not ethical to be done in real-life. This will rely on a computer program that is able to simulate GPS jamming, drone flight, and/or hacking

## Thinking Abstractly and Visualisation

Abstraction is the process of removing unnecessary or irrelevant information in order to simplify a problem or interface. This will be especially useful in my game, as it needs to be simple and understandable for my target audience. My game needs to provide a challenge, but it must be clear what to do or what the next steps are:

* **Removing Street and Business Names:** Google's Satellite Map displays an excess of information, much of which will be irrelevant and even detract from gameplay. Business names and icons for instance are parts of the map which are not integral to gameplay and will only crowd the screen, and distract from the indications of icons for in-game items. Furthermore, street signs will be removed in order to increase team communication, and to ensure that certain mechanics remain unaffected (see [#hacking-puzzles](1.4a-features-of-the-proposed-solution.md#hacking-puzzles "mention"))
* **"Hacking" Interfaces or Puzzles:** My game will not be able to feature actual hacking or penetration testing simulations, due to it be inaccessible and too complex for the vast majority of people, young and old. Therefore, my game will include problems that rely on maths and problem solving, to simulate the kind of thinking required for real-life hacking.
* **Simple and clear user interface**: In order to simplify the complex requests that need to occur when the user wants to perform in-game actions, this will be abstracted with a variety of clearly marked buttons and menus.
* **Player indicators**: Players will be represented on the map with appropriately coloured circles to reduce clutter on the map and make it easier to locate other players (only Hunters). Similarly, the game server will only interpret player position as co-ordinates - stripping out all other non-essential information.

## Thinking Ahead

Thinking Ahead means planning out code and program flow in a way that ensures optimal efficiency for your program. This could involve caching data to be used at a later date, for instance, my game will need to have immediate access to player location, so this would be cached in a fast, server-side memory store.

The flow and design needs to be planned out beforehand, in order to ensure that I work on these base infrastructure tasks - I will need to build the infrastructure to handle fast communication between nodes, before beginning work on the actual gameplay. Planning out how I want the game to feel beforehand is useful, because I can make certain design choices in the basic stages of development, which allow for the best performance.

## Thinking Procedurally and Decomposition

Thinking Procedurally is a way of analysing a problem and breaking it down into smaller, more understandable parts, so you can create a computer program in a simpler and easier way. This is incredibly useful in game design, as it allows complex functionality to be developed by building up from small subroutines or procedures that can be developed more efficiently.

In each development cycle, I will need to focus on a small array of subtasks which are manageable to complete, and build up to the end result. This will allow me to focus on development without getting intimidated or overwhelmed with the scope of my game.

## Thinking Logically

Logical thinking involves tracing the output or behaviour of an algorithm by predicting its flow. This is useful in game development because you can determine the expected output and the actual output of an algorithm or subroutine and compare until the actual and expected outcomes are the same. Some examples of where I will use "Thinking Logically" in my game:

* **Collecting Items:** When a player approaches an item, their phone should automatically prompt them to interact with or collect said item.
* **Moving around the map**: When a player moves around in real life, their location should update on their screen and the screens of all other players.



## Thinking Concurrently
