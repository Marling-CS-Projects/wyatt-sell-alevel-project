# 1.4b Computational Methods

Computational Thinking is a collection of technique used to solve problems with a computer algorithm. It involves analysing a problem, and working out the optimal and most future-proof way it can be represented in computer code. This is incredibly important for large programming projects such as my game, and the reasons are outlined below:

* Data needs to be shared and communicated across multiple devices in realtime. This will rely on a computers ability to handle multiple concurrent streams of data, and interact between them.
* A user needs to have a clear UI with "items" overlayed onto the real world. A computer program is needed here as it is not possible or feasible to have physical, working items in specific locations.
* Various in-game items and actions will need to be simulated as they are not ethical to be done in real-life. This will rely on a computer program that is able to simulate GPS jamming, drone flight, and/or hacking

## Thinking Abstractly and Visualisation

Abstraction is the process of removing unnecessary or irrelevant information in order to simplify a problem or interface. This will be especially useful in my game, as it needs to be simple and understandable for my target audience. My game needs to provide a challenge, but it must be clear what to do or what the next steps are:

* **Removing Street and Business Names:** Google's Satellite Map displays an excess of information, much of which will be irrelevant and even detract from gameplay. Business names and icons for instance are parts of the map which are not integral to gameplay and will only crowd the screen, and distract from the indications of icons for in-game items. Furthermore, street signs will be removed in order to increase team communication, and to ensure that certain mechanics remain unaffected (see [#hacking-puzzles](1.4a-features-of-the-proposed-solution.md#hacking-puzzles "mention"))
* **"Hacking" Interfaces or Puzzles:** My game will not be able to feature actual hacking or penetration testing simulations, due to it be inaccessible and too complex for the vast majority of people, young and old. Therefore, my game will include problems that rely on maths and problem solving, to simulate the kind of thinking required for real-life hacking.
* **Simple and clear user interface**: In order to simplify the complex requests that need to occur when the user wants to perform in-game actions, this will be abstracted with a variety of clearly marked buttons and menus.
* **Player indicators**: Players will be represented on the map with appropriately coloured circles to reduce clutter on the map and make it easier to locate other players (only Hunters). Similarly, the game server will only interpret player position as co-ordinates - stripping out all other non-essential information.

## Thinking Ahead

Thinking Ahead means planning out code and program flow in a way that ensures optimal efficiency for your program. This could involve caching data to be used at a later date, for instance, my game will need to have immediate access to player location, so this would be cached in a fast, server-side memory store.

The flow and design needs to be planned out beforehand, in order to ensure that I work on these base infrastructure tasks - I will need to build the infrastructure to handle fast communication between nodes, before beginning work on the actual gameplay. Planning out how I want the game to feel beforehand is useful, because I can make certain design choices in the basic stages of development, which allow for the best performance.

## Thinking Procedurally and Decomposition

Thinking Procedurally is a way of analysing a problem and breaking it down into smaller, more understandable parts, so you can create a computer program in a simpler and easier way. This is incredibly useful in game design, as it allows complex functionality to be developed by building up from small subroutines or procedures that can be developed more efficiently.

In each development cycle, I will need to focus on a small array of subtasks which are manageable to complete, and build up to the end result. This will allow me to focus on development without getting intimidated or overwhelmed with the scope of my game.

## Thinking Logically

Logical thinking involves tracing the output or behaviour of an algorithm by predicting its flow and specific _decision points_. This is useful in game development because you can determine the where decisions should occur and the outcome of those decisions depending on the algorithms inputs and conditions. Some examples of where I will use "Thinking Logically" in my game:

* **Collecting Items:** When a player approaches an item, my game needs to make a decision - in this case it should automatically prompt them to interact with or collect said item.
* **Moving around the map**: When a player moves around in real life, my game will need to decide whether their movement is a result of them moving or GPS jitter. My game will then update their location for all other players if it is determined to be genuine movement
* **Hacking puzzles**: When a player is completing [#hacking-puzzles](1.4a-features-of-the-proposed-solution.md#hacking-puzzles "mention"), my game will need to have an algorithm that can determine the current state of the puzzle (solved or unsolved), and then give clues accordingly.

## Thinking Concurrently

Thinking Concurrently involves developing programs that are designed to execute multiple tasks simultaneously. This utilises the benefits provided by multi-core or multi-threaded processors. This is important for live multiplayer games, as communication needs to occur between each node concurrently, otherwise there is the possibility for packet or data loss. NodeJS is only single-threaded, so it can never truly operate _concurrently -_ however, for the players connected, it will _appear_ to behave concurrently (within \~10ms)

* **Player location updates**: Multiple players may be moving at one time, and the server needs to handle each connection simultaneously. It also needs to broadcast locations updates to other connected nodes, all at the same time.
* **Collecting or dropping items**: When a player drops or collects an item, the map for all other players needs to be updated accordingly.
* **Player-to-Player interactions**: [#power-up-items](1.4a-features-of-the-proposed-solution.md#power-up-items "mention") often have functionality which is designed to affect multiple players at the same time - for instance, a GPS Jammer needs to "scramble" the location of multiple nearby players at the same time.
